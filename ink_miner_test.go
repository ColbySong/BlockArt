package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"

	"./blockartlib"
	"./blockchain"

	"reflect"
	"strings"
	"testing"
)

const GENESIS_BLOCK_HASH = "83218ac34c1834c26781fe4bde918ee4"
const RANDOM_NONCE = 1 // just putting a random nonce in the block since we are not testing it
const SVG_OP_ONE = "<path d=\"M 0 0 L 20 20\" stroke=\"red\" fill=\"transparent\"/>"
const SVG_OP_TWO = "<path d=\"M 30 30 L 40 40\" stroke=\"red\" fill=\"transparent\"/>"
const SVG_OP_THREE = "<path d=\"M 50 50 L 60 60\" stroke=\"red\" fill=\"transparent\"/>"
const SVG_INVALID_OP_ONE = "<path d=\"M 30 30 L 30 800\" stroke=\"red\" fill=\"transparent\"/>"
const SVG_VALID_OP_ONE = "<path d=\"M 300 300 L 310 310\" stroke=\"red\" fill=\"transparent\"/>"

var p256 = elliptic.P256()
var minerOnePrivateKey, _ = ecdsa.GenerateKey(p256, rand.Reader)
var minerOnePublicKey = minerOnePrivateKey.PublicKey
var minerTwoPrivateKey, _ = ecdsa.GenerateKey(p256, rand.Reader)
var minerTwoPublicKey = minerTwoPrivateKey.PublicKey
var mockInkMiner = InkMiner{
	settings: &minerNetSettings,
}
var minerNetSettings = blockartlib.MinerNetSettings{
	CanvasSettings: blockartlib.CanvasSettings{ CanvasYMax: 1000, CanvasXMax: 1000 },
	GenesisBlockHash: GENESIS_BLOCK_HASH,
	InkPerNoOpBlock:  50,
	InkPerOpBlock:    100,
}

// A mock block chain used to test traverse functions
// mimics a chain generated by two miners
// The chain will have the following structure: [(m1) means mined by miner1]
// NO OP BLOCK (m1) <- NO OP BLOCK (m2) <- OP BLOCK CONTAINING ONE SHAPE BY M1 AND ONE SHAPE BY M2 (m1) <- OP BLOCK CONTAINING ONE SHAPE MADE BY M2 (m2)
var noOPBlockMinerOne = blockchain.Block{
	BlockNum:    1,
	PrevHash:    GENESIS_BLOCK_HASH,
	OpRecords:   make(map[string]*blockchain.OpRecord),
	MinerPubKey: &minerOnePublicKey,
	Nonce:       RANDOM_NONCE,
}
var blockOneHash = ComputeBlockHash(noOPBlockMinerOne)

var noOPBlockMinerTwo = blockchain.Block{
	BlockNum:    2,
	PrevHash:    blockOneHash,
	OpRecords:   make(map[string]*blockchain.OpRecord),
	MinerPubKey: &minerTwoPublicKey,
	Nonce:       RANDOM_NONCE,
}
var blockTwoHash = ComputeBlockHash(noOPBlockMinerTwo)

// Generate OP-SIG
var svgOPOne = []byte(SVG_OP_ONE)
var r1, s1, _ = ecdsa.Sign(rand.Reader, minerOnePrivateKey, svgOPOne)
var svgOpTwo = []byte(SVG_OP_TWO)
var r2, s2, _ = ecdsa.Sign(rand.Reader, minerTwoPrivateKey, svgOpTwo)
var svgOpThree = []byte(SVG_OP_THREE)
var r3, s3, _ = ecdsa.Sign(rand.Reader, minerTwoPrivateKey, svgOpThree)

var minerOneOpRecordOne = blockchain.OpRecord{
	Op:           SVG_OP_ONE,
	InkUsed:      20,
	OpSigR:       r1,
	OpSigS:       s1,
	AuthorPubKey: minerOnePublicKey,
}
var opRecOneHash = ComputeOpRecordHash(minerOneOpRecordOne)

var minerOneOpRecordTwo = blockchain.OpRecord{
	Op:           SVG_OP_TWO,
	InkUsed:      10,
	OpSigR:       r2,
	OpSigS:       s2,
	AuthorPubKey: minerTwoPublicKey,
}
var opRecTwoHash = ComputeOpRecordHash(minerOneOpRecordTwo)

var minerTwoOpRecord = blockchain.OpRecord{
	Op:           SVG_OP_THREE,
	InkUsed:      10,
	OpSigR:       r3,
	OpSigS:       s3,
	AuthorPubKey: minerTwoPublicKey,
}
var opRecThreeHash = ComputeOpRecordHash(minerTwoOpRecord)

var opRecordsBlockThree = make(map[string]*blockchain.OpRecord)
var opBlockMinerOne = blockchain.Block{
	BlockNum:    3,
	PrevHash:    blockTwoHash,
	OpRecords:   opRecordsBlockThree,
	MinerPubKey: &minerOnePublicKey,
	Nonce:       RANDOM_NONCE,
}
var blockThreeHash = ComputeBlockHash(opBlockMinerOne)

var opRecordsBlockFour = make(map[string]*blockchain.OpRecord)
var opBlockMinerTwo = blockchain.Block{
	BlockNum:    4,
	PrevHash:    blockThreeHash,
	OpRecords:   opRecordsBlockFour,
	MinerPubKey: &minerTwoPublicKey,
	Nonce:       RANDOM_NONCE,
}
var blockFourHash = ComputeBlockHash(opBlockMinerTwo)

var blockChainMock blockchain.BlockChain

var allOpRecords map[string]*blockchain.OpRecord

func setUpBlockChain() {
	opRecordsBlockThree[opRecOneHash] = &minerOneOpRecordOne
	opRecordsBlockThree[opRecTwoHash] = &minerOneOpRecordTwo
	opRecordsBlockFour[opRecThreeHash] = &minerTwoOpRecord

	blocks := make(map[string]*blockchain.Block)
	blocks[blockOneHash] = &noOPBlockMinerOne
	blocks[blockTwoHash] = &noOPBlockMinerTwo
	blocks[blockThreeHash] = &opBlockMinerOne
	blocks[blockFourHash] = &opBlockMinerTwo

	blockChainMock = blockchain.BlockChain{
		Blocks:     blocks,
		NewestHash: blockFourHash,
	}

	//init global vars
	pendingOperations = PendingOperations{all: make(map[string]*blockchain.OpRecord)}
	blockChain = blockChainMock

	allOpRecords = make(map[string]*blockchain.OpRecord)
	allOpRecords[opRecOneHash] = &minerOneOpRecordOne
	allOpRecords[opRecTwoHash] = &minerOneOpRecordTwo
	allOpRecords[opRecThreeHash] = &minerTwoOpRecord

	// Traverses the chain and print out content of each block in the chain
	//newestHash := blockChainMock.NewestHash
	//for blockHash := newestHash; blockHash != GENESIS_BLOCK_HASH; blockHash = blockChainMock.Blocks[blockHash].PrevHash {
	//	block := blockChainMock.Blocks[blockHash]
	//	fmt.Printf("Block Num: %d \nPrevHash: %s \nMinerPubKey: %+v\n", block.BlockNum, block.PrevHash, block.MinerPubKey.X)
	//	if len(block.OpRecords) == 0 {
	//		fmt.Printf("Block %d is a no op block\n\n", block.BlockNum)
	//	} else {
	//		fmt.Printf("Block %d contain the the following operations: \n", block.BlockNum)
	//		for k, _ := range block.OpRecords {
	//			fmt.Println(block.OpRecords[k].Op)
	//			if reflect.DeepEqual(block.OpRecords[k].AuthorPubKey, minerOnePublicKey) {
	//				fmt.Println("The above Operation was done by miner 1")
	//			} else {
	//				fmt.Println("The above Operation was done by miner 2")
	//			}
	//		}
	//		fmt.Println("")
	//	}
	//}

}

func TestGetInkTraversal(t *testing.T) {
	setUpBlockChain()
	if ink := GetInkTraversal(&mockInkMiner, &minerOnePublicKey); ink != 130 {
		t.Errorf("Expected ink for miner 1: 130, but got %d", ink)
	}

	if ink := GetInkTraversal(&mockInkMiner, &minerTwoPublicKey); ink != 130 {
		t.Errorf("Expected ink for miner 2: 130, but got %d", ink)
	}
}

func TestGetShapesTraversal(t *testing.T) {
	setUpBlockChain()
	shapesDrawnByMinersOtherThanMinerOne := []string{"M 50 50 L 60 60", "M 30 30 L 40 40"}
	if shapes := GetShapeTraversal(&mockInkMiner, &minerOnePublicKey); !reflect.DeepEqual(shapesDrawnByMinersOtherThanMinerOne, shapes) {
		t.Errorf("Expected shapes for miner 1: %v, but got %v", shapesDrawnByMinersOtherThanMinerOne, shapes)
	}

	shapesDrawnByMinersOtherThanMinerTwo := []string{"M 0 0 L 20 20"}
	if shapes := GetShapeTraversal(&mockInkMiner, &minerTwoPublicKey); !reflect.DeepEqual(shapesDrawnByMinersOtherThanMinerTwo, shapes) {
		t.Errorf("Expected shapes for miner 2: %v, but got %v", shapesDrawnByMinersOtherThanMinerTwo, shapes)
	}
}

func TestGetOpRecordTraversal(t *testing.T) {
	setUpBlockChain()
	opRec, blockHash, exists := GetOpRecordTraversal(opRecThreeHash, mockInkMiner.settings.GenesisBlockHash)
	if !reflect.DeepEqual(opRec, minerTwoOpRecord) || !reflect.DeepEqual(blockHash, blockFourHash) || !exists {
		t.Errorf("Expected opRecord for %s: %+v, but got %+v; and expected blockHash %s, but got %s", opRecThreeHash, minerTwoOpRecord, opRec, blockFourHash, blockHash)
	}
}

func TestIsValidatedByValidateNumOf1(t *testing.T) {
	setUpBlockChain()
	blockHash, validated := IsValidatedByValidateNum(opRecOneHash, 1, mockInkMiner.settings.GenesisBlockHash, &minerOnePublicKey)
	if !strings.EqualFold(blockHash, blockThreeHash) || !validated {
		t.Errorf("Expected opRecordHash %s with validateNum of %d to be validated: %d, but got %d"+
			";and to be in block with blockhash: %s, but got %s ", opRecOneHash, true, validated, blockThreeHash, blockHash)
	}
}

func TestVerifyOpRecordAuthor(t *testing.T) {
	setUpBlockChain()
	if authorVerified := VerifyOpRecordAuthor(minerTwoPublicKey, minerTwoOpRecord); !authorVerified {
		t.Errorf("Expected author with pub key %+v to be verified for opRecord %v", minerTwoPublicKey, minerTwoOpRecord)
	}

	if authorVerified := VerifyOpRecordAuthor(minerTwoPublicKey, minerOneOpRecordOne); authorVerified {
		t.Errorf("Expected author with pub key %+v to be not verified for opRecord %v", minerTwoPublicKey, minerOneOpRecordOne)
	}

	// if miner two was malicious and changed the author public key to it's own, author verification should fail for the opRecord
	minerOneOpRecordOne.AuthorPubKey = minerTwoPublicKey
	if authorVerified := VerifyOpRecordAuthor(minerTwoPublicKey, minerOneOpRecordOne); authorVerified {
		t.Errorf("Expected author with pub key %+v to be not verified for opRecord %v", minerTwoPublicKey, minerOneOpRecordOne)
	}
}

func TestIsValidOperation(t *testing.T) {
	setUpBlockChain()
	minerOneInvalidOp := blockchain.OpRecord{
		Op: SVG_INVALID_OP_ONE,
		InkUsed: 900,
		OpSigR: r1,
		OpSigS: s1,
		AuthorPubKey: minerOnePublicKey,
	}
	minerOneValidOp := blockchain.OpRecord{
		Op: SVG_VALID_OP_ONE,
		InkUsed: 10,
		OpSigR: r1,
		OpSigS: s1,
		AuthorPubKey: minerOnePublicKey,
	}

	if isValidOperation(&mockInkMiner, minerOneInvalidOp) {
		t.Error("Expected isValidOperation to return false, but returned true")
	}

	if !isValidOperation(&mockInkMiner, minerOneValidOp) {
		t.Error("Expected isValidOperation to return true, but returned false")
	}
}

func TestGetAllOperationsFromBlockChain(t *testing.T) {
	setUpBlockChain()
	if opRecs := GetAllOperationsFromBlockChain(blockChainMock, GENESIS_BLOCK_HASH); !reflect.DeepEqual(opRecs, allOpRecords) {
		t.Errorf("Expected all opRecords to match")
	}
}
